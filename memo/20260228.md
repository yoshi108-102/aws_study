とりあえずcloudfrontとはなんぞやというところから...
https://aws.amazon.com/jp/cloudfront/
要するにAWSのCDNサービスのことらしい。CDNそのものはセキュリティ対策というか読み込み高速化のための
キャッシュサーバみたいなやつだったような...?
いちいちオリジンサーバに接続しないで、キャッシュサーバを経由させると高速にページローディングできるから、世界のいろんなところにキャッシュサーバのネットワークをおいておいて、ユーザになるべく物理的に近い位置のサーバから呼び出しますとか
https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html

https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowCloudFrontWorks.html
上の説明では本当にただのキャッシュサーバっぽい。
ユーザに近くていっぱい存在する小さめのエッジロケーション(CloudFront PoP)と、それよりは少ないけど大きめのリージョンエッジキャッシュを組み合わせているらしい
![alt text](image.png)

https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/getting-started-secure-static-website-cloudformation-template.html
↑が安全なWebsiteの作り方みたいなのの説明
https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html
ここのACMとかいうのをアタッチするとHTTPS接続できるということなので、CloudFrontというよりACMが主体としてセキュリティを担っているのかも
SSL/TLSを使うには、認証局の認可サーバに証明書を置いておく必要があるはずなので、そこら辺の処理を勝手にやってくれるのが嬉しいポイントか

とりあえず作ってもらうことにした ACMを使ってと言ったら、自分の取得ずみのドメインを要求されたので、持っていないと言ったらCloudFrontのデフォルトで運用可能らしい

```bash
 Error: No valid credential sources found
│
│   with provider["registry.terraform.io/hashicorp/aws"],
│   on main.tf line 18, in provider "aws":
│   18: provider "aws" {
│
│ Please see https://registry.terraform.io/providers/hashicorp/aws
│ for more information about providing credentials.
│
│ Error: failed to refresh cached credentials, create oauth2 token: login
│ session has expired, please reauthenticate
```
ログイン失敗したっぽいので `aws login`をやり直す
```bash
Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
```
と出るものの成功。`terraform plan`をしたときに`-out`オプションでセーブしていないため、`terraform apply`をしたときに全く同じ動きをすることは保証できませんよということか（前回もdepends_onのときに似たようなことがあったが、terraformの内部のビルドの順番とかはよくわかんない部分があるので、planの時はうまく行っていたがapplyの時に失敗するかもしれんよということだと思う）

と言っている間にビルドが終了。
https://d2xkjehl25xbnc.cloudfront.net/
からアクセスできた。 `main.tf`の中身を見ると、

```terraform
# CloudFront OAC からのアクセスのみ許可するバケットポリシー
resource "aws_s3_bucket_policy" "website" {
  depends_on = [aws_s3_bucket_public_access_block.website]

  bucket = aws_s3_bucket.website.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "AllowCloudFrontServicePrincipal"
        Effect = "Allow"
        Principal = {
          Service = "cloudfront.amazonaws.com"
        }
        Action   = "s3:GetObject"
        Resource = "${aws_s3_bucket.website.arn}/*"
        Condition = {
          StringEquals = {
            "AWS:SourceArn" = aws_cloudfront_distribution.website.arn
          }
        }
      }
    ]
  })
}
```
Condition: AWS:SourceArn = aws_cloudfront_distribution.website.arn
なので、このCloudFront Distributionから来た要求のみ許可するという仕組みになっているということだそうだ。
DNS的にみても、net -> cloudfront -> xxxという感じで遷移するので、S3にアクセスするのにcloudfrontを経由しているなというのはなんかわかる。

これはS3へのURL直通を不許可にすることができているはずなので、
https://tf-s3-website-https-3c291bfe.s3.ap-northeast-1.amazonaws.com/index.html
としたら、
```xml
<Error>
<Code>AccessDenied</Code>
<Message>Access Denied</Message>
<RequestId>---</RequestId>
<HostId>---=</HostId>
</Error>
```
と出たので、うまく行ってそう！